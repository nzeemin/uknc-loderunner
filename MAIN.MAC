	.TITLE	LODERUN
	.MCALL	.EXIT,.TTYIN

START:
	BIS     #010000, @#44	; Disable Ctrl-C

	CALL	Z01064

	.EXIT

MENUP:	.WORD	1		; Текущий пункт меню

Z01060:	;STUB
; Формирование экрана главного меню
Z01064:
	CLR	Z11306
	CLR	Z11304
	MOV	#MENUSC, R1	; Строка главного меню
	CALL	PRINT
	MOV	#1, MENUP

Z01404:
	.TTYIN			; Ожидание нажатия клавиши
; Сюда приходим после нажатия клавиши в меню
Z01406:	MOV	MENUP, R2	; Текущий пункт меню
	CMPB	R0, #12		; Enter?
	BEQ	Z01430
	CMPB	R0, #40		; Пробел?
	BEQ	Z01430		; Да => переходим
	CMP	R0, #000012
	BNE	Z01504
Z01430:	CMP	R2, #1		; Пункт 1 ИГРА ?
	BNE	Z01446		; Нет => переходим
	CALL	Z14600		; ИГРА
	BR      Z01060
Z01446:
	RETURN	;STUB

Z01504:	CMP	R0, #000032	; Стрелка вверх?
	BNE	Z01530
	EMT	000026
	CMP	R2, #000017
	BMI	Z01404
	DEC	R2
	EMT	000024
	BR	Z01404
Z01530:	CMP	R0, #000033	; Стрелка вниз?
	BNE	Z01404
	EMT	000026
	CMP	R2, #000021
	BPL	Z01404
	INC	R2
	EMT	000024
Z01552:	BR	Z01404

MENUSC:	; Строка подготовки экрана меню
	.BYTE	33,246,62	; Формат экрана 40x24
	.BYTE	33,240,67	; Цвет символа
	.BYTE	33,241,60	; Цвет знакоместа 0
	.BYTE	33,242,60	; Цвет фона 0
	.BYTE	14		; Clear screen
	.BYTE	33,131,42,51	; Курсор в позицию
	.ASCII	/L O D E    R U N N E R/<25><25>
	.BYTE	33,240,63	; Цвет символа
	.BYTE	33,131,45,42	; Курсор в позицию
	.ASCII	/1 GAME/<25>
	.ASCII	/  2 /<25>
	.ASCII	/  3 /<25>
	.ASCII	/  4 EXIT/
	.BYTE	15,34,34,34	; Курсок к пункту 1
	.BYTE	0
	.EVEN

GAMESC:	; Строка подготовки игрового экрана
	.BYTE	33,246,62	; Формат экрана 40x24
	.BYTE	33,240,64	; Цвет символа
	.BYTE	33,241,60	; Цвет знакоместа 0
	.BYTE	33,242,60	; Цвет фона 0
	.BYTE	14		; Clear screen
	.BYTE	33,131,40,51	; Курсор в позицию
	.BYTE	33,240,67	; Цвет символа
	.ASCII	/L O D E    R U N N E R/<25><25>
	.BYTE	33,131,66,45	; Курсор в позицию
	.ASCII	/SCORE       LIVES     LEVEL /
	.BYTE	33,240,64	; Цвет символа
	.BYTE	0
GAMES2:	.BYTE	33,131,66,67,0	; Курсор в место где жизни
	.EVEN

; Ожидание символа с клавиатуры: R0 = полученный символ
TTYIN:	TSTB	@#177560	; Приёмник канала 0 готов?
	BPL	TTYIN		; нет => ждём
	MOVB	@#177562, R0	; получаем символ
	RETURN

; Вывод символа на экран: R0 = символ
TTYOUT:	TSTB	@#177564	; Источник канала 0 готов?
	BPL	TTYOUT		; нет => ждём
	MOVB	R0, @#177566	; передаём символ в канал 0
	RETURN

; Печать строки: R1 = адрес строки, строка завершается 0; портит R0
PRINT:
PR0:	MOVB	(R1)+, R0	; Конец строки?
	BEQ	PR2		; да => завершаем
PR1:	TSTB	@#177564	; Источник канала 0 готов?
	BPL	PR1		; нет => ждём
	MOV	R0, @#177566	; передаём символ в канал 0
	BR	PR0
PR2:	RETURN

PAUSE:	; Pause to let PPU finish the previous commands
	MOV	#177777, R5
PAUSE0:	NOP
	SOB	R5, PAUSE0
	RETURN

	.BLKW	72		; ADDRESS ALIGNMENT GAP
;
; Блок переменных
;
Z01700::
	.WORD	10		;
Z01702:	.WORD	0		; Количество людей??? очищается, инкрементируется
Z01704:	.WORD	0		; Адрес в образе лабиринта, инициализируется 011410
Z01706:	.WORD	0		; Адрес текущего слова для текущего лабиринта
Z01710:	.WORD	1		; Номер лабиринта; инициализируется из 001770
Z01712:	.WORD	0		; Счетчик строк при рисовании лабиринта: инициализируется 20., декрементируется
Z01714:	.WORD	0		; Адрес начала текущего лабиринта -- определения в виде триплетов; инициализируется 023640 + 240. * N
Z01716:	.WORD	0		; ??? адрес куда пишем по 5 слов, инициализируется 022070, для элемента 4 -- чертей
Z01720:	.WORD	0		; Адрес в растре: инициализируется 043202, добавляется по 640.
				;   в игровой логике: инициализируется 024000, сравнивается с 024000
Z01722:	.WORD	0		; ??? инициализируется 012600, 013160, 
Z01724:	.WORD	0		; ??? инициализируется 013660, 013704
; Запись об игровом объекте, из 5-ти слов, копируется из 011100
Z01726:	.WORD	0		; Адрес в растре
Z01730:	.WORD	0		; Адрес в образе лабиринта
Z01732:	.WORD	1		; ??? 0/1/2/3; 2 -- падаем
Z01734:	.WORD	1		; ??? 0/1/2/3/4
Z01736:	.WORD	0		; Смещение по высоте ??? если не 0 то спрайт выводится выше на 5 строк
Z01740:	.WORD	0		; ??? сравнивается с 011200
Z01742:	.WORD	31		; ???
Z01744:	.WORD	10		; ??? сравнивается с адресом в образе лабиринта
Z01746:	.WORD	32		; ???
Z01750:	.WORD	33		; ???
Z01752:	.WORD	0		; ???
Z01754:	.WORD	0		; ??? проверяется на 0
Z01756:	.WORD	0		; Количество жизней: инициализируется 10., декрементируется
Z01760:	.WORD	0		; ??? инициализируется 1, очищается, инкрементируется
Z01762:	.WORD	0		; Количество чертей; не больше 20.
Z01764:	.WORD	0		; ???
Z01766:	.WORD	0		; Количество сундуков осталось
Z01770:	.WORD	1		; Номер текущего уровня
Z01772:	.WORD	0
Z01774:	.WORD	0		; 011410 + байтовое значение -- адрес в образе лабиринта где будет выход
Z01776:	.WORD	0		; Текущее количество очков


	.BLKW	1014		; ADDRESS ALIGNMENT GAP
; Подпрограмма подготовки экрана: очистка, рисование рамки
Z04030::
	MOV	#GAMESC, R1	; Строка для подготовки игрового экрана
	CALL	PRINT
	MOV	Z01770, R4	; берём номер текущего уровня
	CALL	Z20074		; вывести номер уровня -- двузначное число
	MOV	#GAMES2, R1	; Курсор к месту где жизни
	CALL	PRINT
	MOV	Z01756, R4	; берём количество жизней
	CALL	Z20050		; выводим 3-значное число
	CALL	PAUSE		; Перед рисованием рамки нужно чтобы завершились предыдущие команды
; Рисование прямоугольной рамки игрового поля (80.,44.)-(560.,245.)
; Draw left/right lines
Z04036:	MOV	#103344, R1	; 100000 + 44.*50 + 40./8 - 1
	MOV	#103403, R2	; R1 + 240./8 + 1
	MOV	#202., R5	; Number of lines
1$:	MOV	R1, @#176640
	MOV	#100200, @#176642	; Left part
	ADD	#80., R1	; Next line
	MOV	R2, @#176640
	MOV	#0401, @#176642	; Right part
	ADD	#80., R2	; Next line
	SOB	R5, 1$
; Draw top/bottom lines
	MOV	#103345, R1
	MOV	#142665, R2	; R1 + 80.*201
	MOV	#30., R5	; 240./8
2$:	MOV	R1, @#176640
	MOV	#177777, @#176642
	INC	R1
	MOV	R2, @#176640
	MOV	#177777, @#176642
	INC	R2
	SOB	R5, 2$
Z04156:	RETURN

	.BLKW	271		; ADDRESS ALIGNMENT GAP
Z05000::
	NOP	
	CLR	Z01702		; Очищаем количество людей???
	CLR	Z01762		; Очищаем количество чертей
	CLR	Z01766		; Очищаем количество сундуков
	MOV	#Z22070, 001716	; Начало массива чертей
	MOV	#<Z24220 - 240.>, R1
	MOV	Z01710, R0	; Номер лабиринта
Z05034:	ADD	#000360, R1	; 240. байт занимает один лабиринт
	SOB	R0, Z05034	; повторяем пока не найдём нужный лабиринт
	MOV	R1, Z01714	; Сохраняем адрес начала текущего лабиринта
	MOV	#Z11410, Z01704	; Адрес начала образа лабиринта
	MOV	R1, Z01706	; Сохраняем адрес текущего лабиринта
	MOV	#103465, Z01720	; начальное значение (потом будем добавлять по 800.)
	MOV	#000024, Z01712	; 20. строк
; Цикл по строкам
Z05074:	MOV	Z01720, R3
	MOV	#6, R5		; 6 слов по 5 триплетов = 30 элементов в строке
; Цикл по R5 -- по словам
Z05104:	MOV	Z01706, R1	; Получаем адрес откуда читаем лабиринт
	MOV	(R1), R0	; Читаем очередное слово
	MOV	#5, R4		; 5 -- количество триплетов в слове
; Цикл по R4 -- по триплетам в слове
Z05116:	MOV	R0, R2
	BIC	#107777, R2	; оставить только биты 12-14 -- верхний триплет
	MOV	#000014, R1	; 12. раз
Z05130:	ROR	R2		; повторить битовый сдвиг вправо
	SOB	R1, Z05130	; в итоге оставленные биты передвинуты в 0-2 биты
; Дальше рисуем элемент для прочитанного триплета
	MOV	Z01704, R1	; Получаем адрес в образе лабиринта
	CMP	R2, #6		; R2 = 6 ? сундук?
	BNE	Z05160		; нет => переходим
; R2 = 6 -- сундук
	BR	Z05456
;
Z05154:	INC	Z01766		; количество сундуков
Z05160:	MOVB	R2, (R1)
	CMP	R2, #000004	; R2 = 4 ? это чёрт?
	BNE	Z05240		; Нет => переходим
; R2 = 4 -- чёрт
	CMP	Z01762, #000024	; чертей меньше 20. ?
	BMI	Z05210		; да => переходим
; Сохраняем чёртика
Z05210:	INC	Z01762		; чертей на один больше
	MOV	Z01716, R2	; Адрес 5-словной записи объекта
	MOV	R3, (R2)+	; сохраняем адрес в растре
	MOV	R1, (R2)+	; сохраняем адрес в образе лабиринта
	CLR	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	MOV	R2, Z01716	; Сохраняем новый адрес
	BR	Z05422
; R2 != 4
Z05240:	BR	Z05430
; Создаём человечка: подготовка объекта из 5-ти слов по 011100
Z05242:	MOV	#Z11100, R2	; Адрес игровой записи
	MOV	R3, (R2)+	; Адрес в растре
	MOV	R1, (R2)+	; Адрес в образе лабиринта
	CLR	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	MOV	#000005, R2	; 5 -- человечек
	MOVB	R2, (R1)	; пишем в образ лабиринта
	NOP	
; Переходим к следующему триплету
Z05270:	CLC			; Сдвигаем на три разряда влево
	ROL	R0              ; <
	ROL	R0              ; <
	ROL	R0              ; <
	CALL	Z16712
; Получаем адрес спрайта по индексу R2
Z05304:	MOV	#Z13540, R1	; Начало таблицы спрайтов
	TST	R2		
	BEQ	Z05322
Z05314:	ADD	#000024, R1	; Переход к следующему спрайту
	SOB	R2, Z05314
; Приступаем к рисованию спрайта; R1 = адрес спрайта в 10 слов -- 8x10 цветных пикселей
Z05322:	MOV	#000012, R2	; Повторить для 10. строк
Z05326:	MOV	R3, @#176640
	MOV	(R1)+, @#176642	; записываем 8 цветных пикселей в растр
	ADD	#80., R3	; плюс 80. -- переход к следующей строке растра
	SOB	R2, Z05326	; продолжаем цикл по строкам
	SUB	#799., R3	; минус 799. -- возвращаемся на 10. строк назад, плюс 8 цветных пикселей вперёд
	DEC	R4		; Уменьшаем счётчик триплетов
	BNE	Z05116		; Если не последний триплет, то переходим
	ADD	#000002, Z01706	; инкремент адреса откуда читаем -- к следующему слову
	DEC	R5		; цикл по словам
	BNE	Z05104		; переход если не закончили
; Закончили рисовать строку лабиринта
Z05360:	ADD	#800., Z01720	; добавляем 800.
	DEC	Z01712		; Продолжаем цикл по строкам
	BNE	Z05074		;   по значению (001712)
; Закончили рисовать лабиринт -- дальше какая-то подготовка адреса
Z05374:	MOV	Z01710, R2	; Берём номер лабиринта
	NOP	
	ADD	#Z11000, R2	; Добавляем адрес 011000
	MOVB	(R2), R3	; и получаем оттуда байт
	ADD	#Z11410, R3	; Добавляем адрес начала образа лабиринта
	MOV	R3, Z01774	; и сохраняем -- адрес выхода в лабиринте
	RETURN	
;
Z05422:	MOV	#000004, R2
	BR	Z05270		; Переходим к следующему триплету, спрайт и продолжаем
; R2 != 4
Z05430:	CMP	R2, #000005
	BNE	Z05270		; Переходим к следующему триплету, спрайт и продолжаем
; R2 = 5 -- человек
Z05436:	TST	Z01702		; Количество человеков нулевое?
	BEQ	Z05450		; да => переходим
;
Z05450:	INC	Z01702		; теперь есть один человек
	BR	Z05242		; Создаём человечка
; R2 = 6 -- сундук
Z05456:	TST	Z11306
	BEQ	Z05154
	RETURN	;STUB

	.BLKW	12		; ADDRESS ALIGNMENT GAP
; Подпрограмма вывода игрового объекта: R2 = адрес в растре, R3 = адрес в образе лабиринта
Z05500::
	CMP	Z01720, #024000	; Начинаем с поиска игровых объектов
	BEQ	Z05526		; таких не было => выводим новый
	MOV	#024000, R4
Z05514:	CMP	(R4)+, R3	; это он?
	BEQ	Z05602		; да => выходим
	CMP	R4, Z01720	; перебрали все?
	BNE	Z05514		; нет => продолжаем
Z05526:	MOVB	(R3), R5	; получаем номер спрайта
	MOV	#Z13540, R4	; Начало таблицы спрайтов, по 10. слов на спрайт
	TSTB	R5		; спрайт #0 ?
	BEQ	Z05546		; да => переходим
Z05540:	ADD	#000024, R4	;   плюс 20. -- следующий спрайт
	SOB	R5, Z05540	;   повторяем
Z05546:	MOV	#000012, R5	; 10 раз
Z05552:	MOV	R2, @#176640	;   адрес для вывода пикселей
	MOV	(R4)+, @#176642	;   выводим 8 цветных пикселей
	ADD	#80., R2	;   плюс одна строка растра
	SOB	R5, Z05552	;   повторяем
	SUB	#800., R2	; возвращаем адрес растра обратно на 10. строк вверх
	MOV	Z01720, R4	; Теперь запоминаем что объект выводился
	MOV	R3, (R4)	; сохраняем адрес в образе лабиринта
	ADD	#000002, Z01720
Z05602:	RETURN	
;
Z05604:	JMP	Z17700
; Вывод поверх следующего элемента
Z05610:	ADD	#1, R2		; плюс 8 пикселей в растре
	INC	R3		; к следующему элементу
	CALL	Z05500		; Вывод игрового объекта
	SUB	#1, R2		; минус 8 пикселей в растре
	MOV	#000012, R5	; 10 раз
Z05632:	MOV	R2, @#176640
	BIS	(R0)+, @#176642	;   выводим поверх
	INC	R2
	MOV	R2, @#176640
	BIS	(R0)+, @#176642	;   выводим поверх
	ADD	#79., R2	;   следующая строка растра - 8 пикселей
	SOB	R5, Z05632	;   повторяем
Z05644:	RETURN	

Z05646:	JMP	Z17726
; Вывод поверх предыдущего элемента
Z05652:	SUB	#1, R2		; минус 8 пикселей в растре
	DEC	R3		; к предыдущему элементу
	CALL	Z05500		; Вывод игрового объекта
	MOV	#000012, R5	; 10 раз
Z05670: MOV	R2, @#176640	;   адрес для вывода пикселей
	BIS	(R0)+, @#176642	;   выводим поверх
	INC	R2
	MOV	R2, @#176640
	BIS	(R0)+, @#176642	;   выводим поверх
	ADD	#79., R2	;   следующая строка растра - 8 пикселей
	SOB	R5, Z05670	;   повторяем
Z05702:	RETURN	
; Подпрограмма вывода ???; R2 = адрес в растре, R0 = адрес спрайта
Z05704:	CMP	R0, #012000	; R0 < 012000 ?
	BMI	Z05740		; да => вывод всего на 5 строк растра ниже
	ADD	#800., R2	; плюс 10 строк в растре
	CALL	Z05500		; Вывод игрового объекта
	SUB	#800., R2	; минус 10 строк в растре
	SUB	#000036, R3	; минус одна строка в образе лабиринта
	CALL	Z05500		; Вывод игрового объекта
	BR	Z05770
Z05740:	ADD	#400., R2	; плюс 5 строк в растре
	CALL	Z05500		; Вывод игрового объекта
	SUB	#800., R2	; минус 10 строк в растре
	SUB	#000036, R3	; минус одна строка в образе лабиринта
	CALL	Z05500		; Вывод игрового объекта
	ADD	#400., R2	; плюс 5 строк в растре
Z05770:	MOV	#000012, R5	; 10 раз
Z05774: MOV	R2, @#176640
	BIS	(R0)+, @#176642	;   рисуем поверх
	ADD	#80., R2	;   следующая строка растра
	SOB	R5, Z05774	;   повторяем
Z06004:	RETURN	
; Подпрограмма вывода ???; R2 = адрес в растре, R0 = адрес спрайта
Z06006:	CMP	R0, #012000	; R0 < 012000 ?
	BMI	Z06046		; да => вывод всего на 5 строк выше
	SUB	#800., R2	; минус 10 строк растра
	CALL	Z05500		; Вывод игрового объекта
	ADD	#800., R2	; плюс 10 строк растра
	ADD	#000036, R3	; плюс одна строка в образе лабиринта
	NOP	
	NOP	
	CALL	Z05500		; Вывод игрового объекта
	BR	Z06076
Z06046:	SUB	#400., R2	; минус 5 строк растра
	CALL	Z05500		; Вывод игрового объекта
	ADD	#800., R2	; плюс 10 строк растра
	ADD	#000036, R3	; плюс одна строка в образе лабиринта
	CALL	Z05500		; Вывод игрового объекта
	SUB	#400., R2	; минус 5 строк растра
Z06076:	MOV	#000012, R5	; 10 раз
Z06102:	MOV	R2, @#176640
	BIS	(R0)+, @#176642	;   рисуем поверх
	ADD	#80., R2	;   следующая строка растра
	SOB	R5, Z06102	;   повторяем
Z06112:	RETURN	
; Подпрограмма ??? игровая логика; R0 = адрес в образе лабиринта
Z06114:	CMP	R1, #000001
	BNE	Z06130
	CALL	Z06152
	BR	Z06150
Z06130:	CMP	R1, #000003
	BNE	Z06144
	CALL	Z06152
	BR	Z06150
Z06144:	CALL	Z16366
Z06150:	RETURN	
; Подпрограмма ??? игровая логика
Z06152:	ADD	#000036, R0	; к следующей строке лабиринта
	TSTB	(R0)		; пустой элемент ?
	BNE	Z06172		; нет => переходим
	MOV	#000002, Z01732	; состояние -- падаем
	BR	Z06334		; на выход
Z06172:	CMPB	(R0), #000007	; под нами лестница ?
	BNE	Z06214		; нет => переходим
	MOV	#000002, R4
	CALL	Z06460
	TST	R5
	BNE	Z06334		; на выход
Z06214:	SUB	#000036, R0	; возвращаемся к текущему элементу лабиринта
	CMPB	(R0), #000007	; лестница ?
	BNE	Z06254		; нет => переходим
	SUB	#000036, R0	; к предыдущей строке лабиринта
	CMPB	(R0), #000007	; лестница ?
	BNE	Z06254		; нет => переходим
	MOV	#000004, R4
	CALL	Z06460
	TST	R5
	BNE	Z06334		; на выход
Z06254:	JMP	Z17404
Z06260:	INC	R0
	CMP	R1, #000001
	BEQ	Z06274
	SUB	#000002, R0
Z06274:	CMPB	(R0), #000001
	BMI	Z06332
	CMPB	(R0), #000002
	BHI	Z06332
	CMP	R1, #000001
	BNE	Z06324
	MOV	#000003, R3
	BR	Z06334		; на выход
Z06324:	MOV	#000001, R3
	BR	Z06334		; на выход
Z06332:	MOV	R1, R3
Z06334:	RETURN	
;
Z06336:	JMP	Z16422
Z06404:	CMP	R1, #000002
	BNE	Z06420	
	ADD	#000037, R0	; к следующей строке +1 элемент
	BR	Z06424
Z06420:	SUB	#000035, R0	; к предыдущей строке +1 элемент
Z06424:	CMPB	(R0), #000007	; лестница ?
	BNE	Z06436		; нет => переходим
	MOV	R1, R3
	BR	Z06456
Z06436:	CMP	R1, #000002
	BNE	Z06452
	MOV	#000004, R3
Z06450:	BR	Z06456
Z06452:	MOV	#000002, R3
Z06456:	RETURN	
; Подпрограмма ???
Z06460:	MOV	Z11102, R2
	CALL	Z06572
	MOV	R3, R5
	MOV	R2, Z01706
	MOV	R0, R2
	CALL	Z06572
	CMP	R3, R5
	BMI	Z06520
	CMP	R4, #000004
	BEQ	Z06562
	BR	Z06532
Z06520:	CMP	R3, R5
	BEQ	Z06532
	CMP	R4, #000002
	BEQ	Z06562
Z06532:	CMP	R2, Z01706
	BMI	Z06550
	CMP	R4, #000003
	BEQ	Z06562
	BR	Z06556
Z06550:	CMP	R4, #000001
	BEQ	Z06562
Z06556:	JMP	Z23150
Z06562:	JMP	Z23202
Z06570:	RETURN	
; Подпрограмма ???
Z06572:	CLR	R3
	SUB	#Z11410, R2	; убираем адрес начала лабиринта, оставляя индекс
Z06600:	INC	R3
	CMP	R2, #000036	; R2 < 30. ?
	BMI	Z06570		; переход на RETURN
	SUB	#000036, R2	; минус 30. -- к предыдущей строке лабиринта
Z06614:	BR	Z06600
; Подпрограмма ???
Z06616:	MOV	Z01730, R3	; Адрес в образе лабиринта
	MOV	Z01726, R2	; Адрес в растре
	CALL	Z20376
	NOP	
	NOP	
	ADD	#400., R2	; ниже на 5 строк растра
	MOV	#000012, R5	; 10. раз
Z06646: MOV	R2, @#176640	;   адрес для вывода пикселей
	MOV	(R0)+, @#176642	;   выводим 8 цветных пикселей
	ADD	#80., R2	;   плюс одна строка растра
	SOB	R5, Z06646	;   повторяем
	SUB	#800., R2	; возвращаемся на 10. строк выше
	MOV	R2, Z01726	; сохраняем новый адрес в растре
	INC	Z01736
	CMP	Z01736, #000002
	BNE	Z06760		; не равно => переход на RETURN
; R2 = 30.
Z06702:	CLR	Z01736
	MOV	Z01730, R2	; берём адрес в образе лабиринта
	ADD	#000036, Z01730	; добавляем 30. -- к следующей строке
	ADD	#000074, R2	; плюс 60. -- на две строки вниз
	BR	Z06762
Z06730:	TST	Z01760
	BNE	Z06744
	CMPB	(R2), #000010
	BEQ	Z06756
Z06744:	CLR	Z01732
	CLR	Z01734
	BR	Z06760
Z06756:	RETURN	;STUB
Z06760:	RETURN	
Z06762:	TSTB	(R2)
	BEQ	Z06760
	CMPB	(R2), #000006
	BEQ	Z06760
Z06774:	BR	Z06730

;	.BLKW	1		; ADDRESS ALIGNMENT GAP
; Подпрограмма ??? игровая логика; по адресу 001726 игровой объект из 5-ти слов
Z07000::
	MOV	#Z13160, Z01722
	MOV	#013704, Z01724
	MOV	#024000, Z01720
	MOV	Z01732, R0	; берём состояние объекта
	CMP	R0, #000001
	BNE	Z07040
	JMP	Z07776
;
Z07040:	CMP	R0, #000002	; падаем ?
	BNE	Z07062		; нет => переходим
	MOV	Z01724, R0
	CALL	Z06616
	JMP	Z07776
Z07062:	JMP	Z16336

Z07070:	RETURN	;STUB

Z07132:	TSTB	@#177560	; Нажата клавиша?
	BPL	Z07262		; нет => переходим
	MOV	@#177562, R0	; код нажатой клавиши
	CMPB	R0, Z01752
	BNE	Z07262
	MOV	Z01730, R1	; берём адрес в образе лабиринта
	ADD	#000036, R1	; к следующей строке лабиринта
	CMPB	(R1), #000002	; под нами кирпичная стена ?
	BNE	Z07262		; нет => переходим
	CMP	Z01740, #011270
	BHI	Z07262
	JMP	Z16252
Z07204:	NOP	
	CALL	Z17014
	CALL	Z17102
	MOV	#000012, R5	; 10. раз
Z07222: MOV	R2, @#176640
	CLR	@#176642	;   очищаем 8 пикселей
	ADD	#80., R2	;   к следующей строке растра
	SOB	R5, Z07222	;   повторяем
	MOVB	#000010, (R1)
	MOV	Z01740, R3
	MOV	R1, (R3)+
	SUB	#800., R2	; на 10. строк выше
	MOV	R2, (R3)+
	MOV	Z11310, (R3)+
	MOV	R3, 001740
Z07262:	CALL	Z17502
	MOV	Z01730, R1	; берём адрес в образе лабиринта
	ADD	#000036, R1	; добавляем 30. -- к следующей строке
	JMP	Z16300
Z07302:	CMPB	(R1), #000010
	BNE	Z07336
; Вход: переходим сюда когда под игровым объектом пусто -- проваливается
Z07310:	MOV	#000002, Z01732	; состояние -- падаем
	CALL	Z23052
	MOV	Z01724, R0
	CALL	Z06616
	JMP	Z07776
Z07336:	MOV	Z01730, R1	; берём адрес в образе лабиринта
	CMP	R0, Z01744
	BNE	Z07570
; Вход: ???
Z07350:	DEC	R1
	CMPB	(R1), #000001
	BMI	Z07366
	CMPB	(R1), #000003
	BMI	Z07560
Z07366:	CMP	Z01734, #000003
	BEQ	Z07452
	TST	Z01736
	BEQ	Z07452
Z07410:	CMP	Z01734, #000003
	BNE	Z07430
	CLR	Z01734
	JMP	Z16204
Z07430:	JMP	Z14572
;
Z07452:	MOV	Z01730, R3	; берём адрес в образе лабиринта
	MOV	Z01726, R2	; берём адрес в растре
	CALL	Z15672
	MOV	Z01736, R5
	TST	R5
	BEQ	Z07504
Z07476:	ADD	#000050, R0
	SOB	R5, Z07476
Z07504:	CALL	Z05646
	INC	Z01736
	CMP	Z01736, #000003
	BNE	Z07546
	SUB	#1, Z01726	; на 8 цветных пикселей левее
	DEC	Z01730		; адрес в лабиринте -- к предыдущему элементу
	CLR	Z01732
	CLR	Z01736
Z07546:	MOV	#000003, Z01734
	JMP	Z07776
Z07560:	JMP	Z07410

Z07570:	CMP	R0, Z01742
	BNE	Z07772
Z07576:	INC	R1
	CMPB	(R1), #000001
	BMI	Z07614
	CMPB	(R1), #000003
	BMI	Z07636
Z07614:	CMP	Z01734, #000001
	BEQ	Z07676
	TST	Z01736
	BEQ	Z07676
Z07636:	CMP	Z01734, #000001
	BNE	Z07656
	CLR	Z01734
	JMP	Z16204
Z07656:	JMP	Z14572
Z07676:	MOV	Z01730, R3	; берём адрес в образе лабиринта
	MOV	Z01726, R2	; берём адрес в растре
	MOV	Z01722, R0
	MOV	Z01736, R5
	TST	R5
	BEQ	Z07730
Z07722:	ADD	#000050, R0
	SOB	R5, Z07722
Z07730:	CALL	Z05604
	INC	Z01736
	CMP	Z01736, #000003
	BEQ	Z07762
Z07750:	MOV	#000001, Z01734
	JMP	Z07776
Z07762:	CLR	Z01732
	JMP	Z14044
Z07772:	JMP	Z14066
Z07776:	RETURN	


Z10106:	TST	Z11110
	BNE	Z10120
	MOV	R0, Z11314
Z10120:	RETURN	
Z10122:	ADD	#000036, R1	; следующая строка лабиринта??
	CMPB	(R1), #000003
	BNE	Z10140
	JMP	Z14376
Z10140:	JMP	Z14362
Z10144:	SUB	#000002, R0
	CMPB	(R0), #000001
	BMI	Z10164
	CMPB	(R0), #000003
	BMI	Z10212
Z10164:	MOV	#000003, R4
	CALL	Z06460
	TST	Z01704
	BNE	Z10206
Z10204:	RETURN	
;
Z10206:	TST	R5
	BNE	Z10204
Z10212:	ADD	#000037, R0	; следующая строка лабиринта + 1 место
	CMPB	(R0), #000006
	BMI	Z10250
Z10250:	SUB	#000036, R0	; следующая строка лабиринта
	CMPB	(R0), #000007
	BNE	Z10316
Z10316:	TST	Z01704
	BEQ	Z10334
	CLR	Z01704
Z10330:	JMP	Z17410

Z10334:	RETURN	;STUB

	.BLKW	350		; ADDRESS ALIGNMENT GAP
; Номера ячеек выхода из лабиринта
Z11000::
	.BYTE	25, 24, 01, 02, 17, 01, 27, 24, 20, 00
	.BYTE	22, 35, 05, 15, 34, 16, 02, 30, 14, 34
	.BYTE	34, 34, 33, 34, 35
	.EVEN

; Подпрограмма ???
Z11040:	INC	Z01714		; 
	TST	Z01754
	BEQ	Z11056
;
Z11056:	RETURN	

; Подпрограмма ???
Z11066:	CLR	Z01714
Z11072:	JMP	Z17004

	.BLKW	11		; ADDRESS ALIGNMENT GAP
Z11100::
	.BLKW	40		;TODO: Уточнить, неясно сколько нужно
Z11102	= Z11100 + 2
Z11104	= Z11100 + 4
Z11106	= Z11100 + 6
Z11110	= Z11100 + 10

Z11144:	.ASCII	/NE TOT TIP FAJLA !!!/

Z11200:	.BLKW	40		; ???
Z11202	= Z11200 + 2
Z11204	= Z11200 + 4

Z11302:	.WORD	0		; ??? очищается, инкрементируется, сравнивается с 10.
Z11304:	.WORD	0		; ??? очищается, инкрементируется
Z11306:	.WORD	0		; ??? очищается, инкрементируется
Z11310:	.WORD	0		; ???
Z11312:	.WORD	0		; ???

Z11314:	RETURN	;STUB

	.BLKW	24		; ADDRESS ALIGNMENT GAP
; Образ текущего лабиринта, байт на элемент, 30. байт на строку, 600 байт всего
Z11410::
	.BLKB	600.

	.BLKW	20		; ADDRESS ALIGNMENT GAP
Z12600::	; Блок спрайтов
	.WORD	170000,000000,170000,000001,030000,000000,177400,000003,177300,000037
	.WORD	176300,000000,176000,000000,107000,000003,103400,000003,003400,000000
	.WORD	000000,000074,000000,000174,000000,000014,140000,000077,170000,001777
	.WORD	146000,000077,100000,000077,100000,000163,170000,000163,070000,000160
	.WORD	000000,000000,000000,001700,000000,003700,000000,003770,000000,037774
	.WORD	000000,007770,000000,003760,000000,007760,000000,001774,000000,001700

Z12770:: ;STUB
	.WORD	000000,000017,100000,000017,000000,000014,140000,000377,176000,001577
	.WORD	000000,001477,000000,000077,140000,000161,140000,000341,000000,000340
	.WORD	036000,000000,037000,000000,030000,000000,176000,000003,177700,000017
	.WORD	176000,000063,176000,000000,147000,000001,147000,000017,007000,000016
	.WORD	000000,000000,001700,000000,001740,000000,017740,000000,037774,000000
	.WORD	017760,000000,007740,000000,007760,000000,037700,000000,001700,000000

Z13160:		; Блок спрайтов
	.WORD	170000,000000,170000,000000,030000,000000,176000,000000,171400,000003
	.WORD	170000,000000,146000,000000,006000,000003,001400,000003,001400,000000
	.WORD	000000,000074,000000,000074,000000,000014,140000,000017,030000,000377
	.WORD	000000,000017,000000,000014,140000,000063,000000,000060,000000,000060

	.BLKW	120		; ADDRESS ALIGNMENT GAP
; Начало области спрайтов, по 10. слов на спрайт, 8 спрайтов
Z13540::
	.WORD	000000,000000,000000,000000,000000,000000,000000,000000,000000,000000
	.WORD	177400,177400,177400,177400,177400,177400,177400,177400,177400,177400
	.WORD	175773,175773,175773,175773,000000,157737,157737,157737,157737,000000
	.WORD	177777,000000,000000,000000,000000,000000,000000,000000,000000,000000
	.WORD	006014,026455,024445,037477,017036,017036,006014,011022,011022,011022
	.WORD	006014,026455,024445,017036,006014,006014,010002,011022,011022,031463
	.WORD	000000,006014,015022,032441,032445,037477,037477,037477,037477,000000
	.WORD	020441,020441,037477,020441,020441,020441,020441,037477,020441,020441

Z14044:	ADD	#000002, Z01726	; Плюс одно слово для адреса в растре
	INC	Z01730		; К следующему элементу в образе лабиринта
	CLR	Z01736
	JMP	Z07750
Z14066:	CMP	R0, Z01746
	BNE	Z14350
Z14074:	CMPB	(R1), #000007
	BNE	Z14264
	SUB	#000036, R1
	CMPB	(R1), #000007
	BNE	Z14260
	CMP	Z01734, #000004
	BEQ	Z14140
	TST	Z01736
	BEQ	Z14140
Z14140:	MOV	Z01730, R3	; берём адрес в образе лабиринта
	NOP	
	NOP	
	TST	Z01736
	BNE	Z14164
	MOV	#010700, R0
	BR	Z14170
Z14164:	MOV	#013660, R0
Z14170:	TST	Z01760
	BNE	Z14202
	ADD	#000024, R0
;
Z14202:	SUB	#400., Z01726	; Адрес растра на 5 строк выше
	CALL	Z15716
	INC	Z01736
	CMP	Z01736, #000002
	BNE	Z14246
	SUB	#000036, Z01730	; Адрес в лабиринте -- на строку выше
	CLR	Z01732
	CLR	Z01736
Z14246:	MOV	#000004, Z01734
	JMP	Z07776
Z14260:	ADD	#000036, R1
Z14264:	MOV	Z01734, R0
	TST	R0
	BEQ	Z14344
	CMP	R0, #000004
	BNE	Z14312
Z14302:	CLR	Z01734
	JMP	Z16204
Z14312:	CMP	R0, #000001
	BNE	Z14324
	JMP	Z07576
Z14324:	CMP	R0, #000002
	BEQ	Z14356
	CMP	R0, #000003
	BNE	Z14344
	JMP	Z07350
Z14344:	JMP	Z07776
Z14350:	CMP	R0, Z01750
	BNE	Z14554
Z14356:	JMP	Z10122
Z14362:	CMPB	(R1), #000007
	BEQ	Z14376
	SUB	#000036, R1
	BR	Z14544
Z14376:	CMP	Z01734, #000002
	BEQ	Z14424
	TST	Z01736
	BEQ	Z14424
Z14424:	MOV	Z01730, R3	; берём адрес в образе лабиринта
	NOP	
	NOP	
	TST	Z01736
	BNE	Z14450
	MOV	#010700, R0
	BR	Z14454
Z14450:	MOV	#013660, R0
Z14454:	TST	Z01760
	BNE	Z14466
	ADD	#000024, R0
Z14466:	ADD	#400., Z01726	; Ниже на 5 строк в растре
	CALL	Z15730
	INC	Z01736
	CMP	Z01736, #000002
	BNE	Z14532
	ADD	#000036, Z01730	; Адрес в лабиринте на строку ниже
	CLR	Z01732
	CLR	Z01736
Z14532:	MOV	#000002, Z01734
	JMP	Z07776
Z14544:	CMP	Z01734, #000002
	BEQ	Z14302
Z14554:	MOV	Z01734, R0
	CMP	R0, #000004
	BNE	Z14312
	JMP	Z14074
Z14572:	MOV	Z01730, R1	; берём адрес в образе лабиринта
Z14576:	BR	Z14554

; Подпрограмма: вызывается по выбору пункта ИГРА в меню
Z14600:	MOV	#000012, Z01756	; 10. -- начальное количество жизней
	CALL	Z20540		; Сбрасываем Номер лабиринта в 1
	NOP	
	CALL	Z20364
	CALL	Z16752
; Вход: после очередной смерти человечка
Z14624:	MOV	Z01770, Z01710	; Номер лабиринта
	CALL	Z04030		; очистка экрана и рисование рамки игрового поля
	CALL	Z15760		; Отрисовать лабиринт
	CALL	Z21636		; ??? Переход к ожиданию перед игрой
	CALL	Z11066
	CALL	Z20172		; Вывод статусной строки
	MOV	#011200, Z01740
Z14664:	CLR	Z01760
	MOV	#Z11100, R0	; Отсюда -- из игровой записи человечка
	MOV	#Z01726, R1	;   сюда
	MOV	#000005, R2	;   5 раз
Z14704:	MOV	(R0)+, (R1)+	;   копируем пословно
	SOB	R2, Z14704	;   повторяем
	CALL	Z07000
	MOV	#Z11100, R0	; Сюда -- в игровую запись человечка
	MOV	#Z01726, R1	;   отсюда
	MOV	#000005, R2	;   5 раз
Z14730:	MOV	(R1)+, (R0)+    ;   копируем пословно
	SOB	R2, Z14730	;   повторяем
	MOV	#012600, Z01722
	MOV	#013660, Z01724
	MOV	#000001, Z01760
;
Z14756:	MOV	Z01760, R5	; Получаем счётчик ???
	MOV	#<Z22070-12>, R0	;   начальный адрес (Z22070 - 12 ??)
Z14766:	ADD	#000012, R0	;   плюс 10.
	SOB	R5, Z14766	;   повторяем
	MOV	R0, Z01764      ; Сохраняем адрес
	MOV	#Z01726, R1	;   сюда
	MOV	#000005, R2     ;   5 раз
Z15010:	MOV	(R0)+, (R1)+	;   копируем пословно
	SOB	R2, Z15010	;   повторяем
	MOV	Z01732, R0	; берём состояние объекта
	CMP	R0, #000001
	BEQ	Z15332
	CMP	R0, #000002	; падаем ?
	BNE	Z15046		; нет => переходим
	MOV	Z01724, R0
	CALL	Z06616
	BR	Z15332
Z15046:	TST	Z01736
	BNE	Z15074
	MOV	Z01730, R0	; берём адрес в образе лабиринта
	MOV	Z01734, R1
	CALL	Z06114
	MOV	R3, R0
	BR	Z15106
Z15074:	MOV	Z01734, R0
Z15100:	MOV	Z01730, R1	; берём адрес в образе лабиринта
	BR	Z15136
Z15106:	MOV	R0, R4
	CALL	Z17544
	TST	R5
	BNE	Z15100
	INC	Z01736
	JMP	Z17152
Z15130:	MOV	Z01730, R1	; берём адрес в образе лабиринта
	BR	Z15262
Z15136:	ADD	#000036, R1	; плюс 30. -- на строку ниже
	CMPB	(R1), #000000	; пустой элемент?
	BNE	Z15156		; нет => переходим
; Ниже на строку пусто -- проваливается
Z15150:	CALL	Z07310
	BR	Z15332
Z15156:	CMPB	(R1), #000010
	BNE	Z15130
	NOP	
	NOP	
	NOP	
	NOP	
	MOVB	#000005, (R1)
	MOV	Z01726, R2	; берём адрес в растре
	MOV	Z01730, R3	; берём адрес в образе лабиринта
	CALL	Z05526
	ADD	#000002, R2
	INC	R3
	CALL	Z05526
	ADD	#001176, R2	; плюс 10 строк растра минус 8 пикселей??
	MOV	#000012, R5	; 10. раз
	MOV	Z01724, R0
Z15242:	MOV	R2, @#176640
	MOV	(R0)+, @#176642	;   заполняем 8 пикселей
	ADD	#80., R2	;   к следующей строке растра
	SOB	R5, Z15242	;   повторяем
	JMP	Z16600
Z15260:	BR	Z15332
Z15262:	CMP	R0, #000003	; верёвка ?
	BNE	Z15276
	CALL	Z07350		; Сдвигается один чёрт
	BR	Z15332
Z15276:	CMP	R0, #000001	; сплошная стена ?
	BNE	Z15312		; нет => переходим
	CALL	Z07576
	BR	Z15332
Z15312:	CMP	R0, #000004	; чёрт ?
	BNE	Z15326
; R0 = 4
Z15320:	CALL	Z14074
	BR	Z15332
Z15326:	CALL	Z14356
;
Z15332:	MOV	Z01764, R0	; Получаем адрес куда копировать
	MOV	#Z01726, R1	;   отсюда
	MOV	#000005, R2	;   5 раз
Z15346:	MOV	(R1)+, (R0)+	;   копируем пословно
	SOB	R2, Z15346	;   повторяем
	INC	Z01760
	CMP	Z01760, Z01762
	BHI	Z15372
	JMP	Z14756
Z15372:	CALL	Z16212
	JMP	Z17514
Z15402:	CMP	(R0), #000057
	BMI	Z15430
	CLR	(R0)
	CALL	Z20302
	CALL	Z20236
	NOP	
	NOP	
	NOP	
Z15430:	MOV	Z11102, R0
	CMPB	(R0), #000006	; это сундук?
	BNE	Z15510		; нет => переходим
	NOP	
	ADD	#000012, Z01776	; плюс 10. очков
	INC	Z11302
	CLRB	(R0)		; удаляем сундук из образа лабиринта
	CALL	Z17126
	CMP	Z11302, #000012
	BMI	Z15510
;
Z15510:	TST	Z01766		; Сундуков больше не осталось?
	BNE	Z15604		; остались => переходим
	MOV	Z01774, R3	; берём адрес выхода
	SUB	#Z11410, R3	; вычитаем адрес начала образа лабиринта
;
Z15604:	MOV	Z01762, R3	; Количество чертей
	MOV	#000001, R1
	MOV	#Z22072, R4	; начало массива чертей 022070 + 1 слово
Z15620:	MOV	(R4), R2	;   получаем адрес в образе лабиринта
	CMP	R0, R2		;   адрес тот же?
	BEQ	Z15636		;   да => выходим, минус одна жизнь
	ADD	#000012, R4	;   к следующей записи
	SOB	R3, Z15620	; повторяем для всех чертей
	BR	Z15654		; проверили всех, нет коллизий
Z15636:	CALL	Z17140		; Минус одна жизнь
	TST	Z01756		; количество жизней = 0 ?
	BEQ	Z15714		; да => переходим
	JMP	Z14624
Z15654:	JMP	Z14664

Z15672:	MOV	R0, R5
	MOV	Z01722, R0
	NOP	
	NOP	
	NOP	
	ADD	#000170, R0
	RETURN	
Z15714:	RETURN	;STUB
;
Z15716:	MOV	Z01726, R2	; берём адрес в растре
	CALL	Z05704		; рисуем спрайт R0 с возможным смещением вниз
	RETURN	
;
Z15730:	MOV	Z01726, R2	; берём адрес в растре
	CALL	Z06006		; рисуем спрайт R0 с возможным смещением вверх
	RETURN	

; Подпрограмма ???
Z15760:	CALL	Z05000		; Рисование лабиринта
	INC	Z11306
	RETURN

	.BLKW	103		; ADDRESS ALIGNMENT GAP
; Подпрограмма ??? игровая логика
Z16000::
	CMP	Z01740, #011200
	BLE	Z16164
	MOV	#Z11204, R0
	MOV	#000010, R3
Z16020:	DEC	(R0)
	ADD	#000006, R0
	SOB	R3, Z16020
	TST	Z11204
	BGT	Z16164
	MOV	Z11202, R1
	MOV	#013610, R2
	MOV	#000012, R3	; 10. раз
Z16052:	MOV	R1, @#176640
	MOV	(R2)+, @#176642	; вывод в растр
	ADD	#80., R1	; на строку растра ниже
	SOB	R3, Z16052
	SUB	#002400, R1
	MOV	R1, R5
	BR	Z16166
Z16072:	NOP	
	MOV	#011206, R3
Z16100:	MOV	(R3)+, (R2)+
	CMP	R3, #011300
	BNE	Z16100
	SUB	#000006, Z01740
	CMPB	(R1), #000005
	BNE	Z16146
	JMP	Z16626
Z16130:	CALL	Z17114
Z16134:	MOV	R5, @#176640
	BIS	(R0)+, @#176642	;   рисуем 8 пикселей поверх
	ADD	#80., R5	;   к следующей строке растра
	SOB	R2, Z16134	;   повторяем
	BR	Z16162
Z16146:	CMP	R1, 011102
	BNE	Z16162
Z16162:	BR	Z16244
Z16164:	RETURN	
Z16166:	MOV	Z11200, R0
	MOV	R0, R1
	MOV	#011200, R2
	BR	Z16072
Z16204:	CLR	Z01736
Z16210:	RETURN	
; Подпрограмма ??? игровая логика
Z16212:	MOV	#024000, R1
Z16216:	SOB	R1, Z16216	; Цикл ожидания
	CALL	Z17044
Z16224:	RETURN

Z16244:	CALL	Z17030
Z16250:	RETURN	
Z16252:	TST	Z01736
	BNE	Z16272
	MOV	#000003, Z01732
	JMP	Z07204
;
Z16272:	RETURN	;STUB
;

	.BLKW	7		; ADDRESS ALIGNMENT GAP
Z16300::
	TSTB	(R1)		; пустой элемент ?
	BNE	Z16310		; нет => переходим
Z16304:	JMP	Z07310
;
Z16310:	CMPB	(R1), #000006
	BEQ	Z16304
	CMP	Z01732, #000003
	BNE	Z16332
	JMP	Z07336
Z16332:	JMP	Z07302
;
Z16336:	TST	Z01736
	BEQ	Z16350
	JMP	Z14572
;
Z16350:	TST	Z01754
	BEQ	Z16362
	JMP	Z07070
;
Z16362:	JMP	Z07132		; Переход к проверке клавиатуры
;
Z16366:	TST	R1
	BNE	Z16400
	CALL	Z06254
	RETURN	
Z16400:	CALL	Z06336
Z16404:	RETURN	

Z16422:	INC	R0
	TSTB	(R0)
	BEQ	Z16444
	CMPB	(R0), #000006
	BEQ	Z16444
	CMPB	(R0), #000007
	BNE	Z16474
Z16444:	ADD	#000036, R0
	TSTB	(R0)
	BEQ	Z16470
	MOV	#000001, R4
	CALL	Z06460
	TST	R5
	BNE	Z16554
Z16470:	SUB	#000036, R0
Z16474:	SUB	#000002, R0
	TSTB	(R0)
	BEQ	Z16520
	CMPB	(R0), #000006
	BEQ	Z16520
	CMPB	(R0), #000007
	BNE	Z16550
Z16520:	ADD	#000036, R0
	TSTB	(R0)
	BEQ	Z16544
	MOV	#000003, R4
	CALL	Z06460
	TST	R5
	BNE	Z16554
Z16544:	SUB	#000036, R0
Z16550:	JMP	Z06404
Z16554:	RETURN	
;
Z16600:	MOV	#000001, Z01732
	ADD	#000036, Z01730	; переходим к следующей строке лабиринта
	ADD	#800., Z01726	; на 10. строк растра ниже
	JMP	Z15260
Z16626:	MOV	#013660, R0
	MOV	#022072, R2
Z16636:	CMP	(R2), R1
	BEQ	Z16650
	ADD	#000012, R2
	BR	Z16636
Z16650:	SUB	#000036, (R2)	; на строку лабиринта выше
	SUB	#000002, R2
	SUB	#800., (R2)	; на 10 строк растра выше
	ADD	#000004, R2
	CLR	(R2)
	JMP	Z16130
Z16712:	INC	Z01704
	TST	Z11304
	BEQ	Z16742
	CMP	R2, #000004
	BEQ	Z16740
	CMP	R2, #000005
	BNE	Z16742
Z16740:	CLRB	(R1)
Z16742:	RETURN	

; Подпрограмма: ???
Z16752:	CLR	Z01776		; Обнуляем количество очков
	INC	Z11304
	RETURN	

; Подпрограмма: ???
Z17000:	CALL	Z20316
Z17004:	MOV	#000070, Z11310
	RETURN	
;
Z17014:	MOV	Z01726, R2	; берём адрес в растре
	ADD	#000003, Z11310
Z17026:	RETURN	
;
Z17030:	MOVB	#000002, (R1)
	SUB	#000003, Z11310
	RETURN	
; Подпрограмма ??? игровая логика
Z17044:	CALL	Z16000
	TST	Z11104
	BNE	Z17100
	TST	Z11106
	BEQ	Z17100
	TST	Z11110
	BNE	Z17100
	CALL	Z17226
	NOP	
Z17100:	RETURN	
;
Z17102:	ADD	#800., R2	; на 10 строк растра ниже??
	CALL	Z17252
	RETURN	
Z17114:	MOV	R5, R3
	CALL	Z20430
	RETURN	
Z17126:	DEC	Z01766		; сундуков стало меньше на один
	CALL	Z17322
Z17136:	RETURN	
;
Z17140:	DEC	Z01756		; Минус одна жизнь
	CALL	Z17360
Z17150:	RETURN	
;
Z17152:	ADD	#000002, R0
	CMP	R0, #000005
	BMI	Z17170
	SUB	#000004, R0
Z17170:	JMP	Z15100

Z17200:	MOV	R4, R5
	NOP ;STUB	MOV	#000300, @#177716	;TODO
Z17210:	SOB	R5, Z17210
	MOV	R4, R5
	NOP ;STUB	MOV	#000200, @#177716	;TODO
Z17222:	SOB	R5, Z17222
Z17224:	RETURN	
;
Z17226:	MOV	#000060, R4
Z17232:	CALL	Z17200
	ADD	#000040, R4
	CMP	R4, #000200
	BMI	Z17232
	RETURN	
Z17252:	MOV	#000100, R4
Z17256:	CALL	Z17200
	ADD	#000003, R4
	CMP	R4, #000200
	BMI	Z17256
	RETURN	
Z17276:	MOV	#001000, R4
Z17302:	CALL	Z17200
	SUB	#000010, R4
	CMP	R4, #000600
	BPL	Z17302
	RETURN	
Z17322:	MOV	#000400, R4
	MOV	#000030, R3
Z17332:	CALL	Z17200
	SOB	R3, Z17332
	ASR	R4
	MOV	#000030, R3
Z17346:	CALL	Z17200
	SOB	R3, Z17346
	JMP	Z20236
Z17360:	MOV	#002000, R4
Z17364:	CALL	Z17200
	SUB	#000005, R4
	CMP	R4, #000600
	BPL	Z17364
Z17402:	RETURN	
;
Z17404:	INC	Z01704
Z17410:	MOV	Z01730, R0	; берём адрес в образе лабиринта
	TST	R1
	BEQ	Z17424
	JMP	Z06260
Z17424:	INC	R0
	CMPB	(R0), #000001
	BMI	Z17442
	CMPB	(R0), #000003
	BMI	Z17470
Z17442:	MOV	#000001, R4
	CALL	Z06460
	TST	Z01704
	BNE	Z17464
	MOV	R4, R3
Z17462:	RETURN	
Z17464:	TST	R5
	BNE	Z17462
Z17470:	JMP	Z10144

Z17502:	CALL	Z22770
	CALL	Z10106
Z17512:	RETURN	
;
Z17514:	CALL	Z11040
	CMP	Z11314, #000014
Z17526:	BNE	Z17534
;
Z17534:	MOV	#Z01714, R0	;
Z17540:	JMP	Z15402
; Подпрограмма ???; R4 = ???
Z17544:	MOV	Z01730, R5	; берём адрес в образе лабиринта
	CMP	R4, #000001
	BEQ	Z17564
	CMP	R4, #000003
	BNE	Z17660		; на выход
; R4 = 1 или 3
Z17564:	SUB	#Z11410, R5	; вычитаем начальный адрес, оставляя индекс
Z17570:	CMP	R5, #000036	;   меньше 30.? первая строка?
	BMI	Z17604		;   да => переходим
	SUB	#000036, R5	;   вычитаем 30. -- на строку выше
	BR	Z17570		;   повторяем
Z17604:	SUB	#000017, R5	; вычитаем 15. -- половину строки
	TST	R5
	BMI	Z17632		; меньше 0 => переходим
	CMP	R4, #000003
	BEQ	Z17660		; на выход
Z17622:	CMP	R5, #000015
	BHI	Z17644		; больше 13. => переходим
	BR	Z17660		; на выход
; R5 меньше нуля -- элемент в первой половине строки
Z17632:	NEG	R5		; меняем знак числа -- теперь это 1..15
	CMP	R4, #000001
	BEQ	Z17660		; на выход
	BR	Z17674
Z17644:	CLR	R5
	CLR     Z01734
	CLR     Z01736
	BR      Z17666
Z17660:	MOV	#000001, R5	; результат -- ???
	RETURN	
Z17666:	DEC     Z01736
	RETURN  
Z17674:	DEC	R5
	BR	Z17622
Z17700:	MOV	#000001, R4
	CALL	Z17544
	TST	R5
	BNE	Z17716
;
Z17716:	CALL	Z05500		; Вывод игрового объекта
	JMP	Z05610		; Вывод поверх следующего элемента
Z17726:	MOV	#000003, R4
	CALL	Z17544
	TST	R5
	BNE	Z17744		; R5 не 0 => переходим
	RETURN	
;
Z17744:	CALL	Z05500		; Вывод игрового объекта
Z17750:	JMP	Z05652		; Вывод поверх предыдущего элемента

; Подпрограмма: вывод 5-значного числа R4
Z20000:	MOV	#000060, R0
	SUB	#023420, R4	; 10000.
	BMI	Z20016
Z20016:	ADD	#023420, R4
	CALL	TTYOUT		; вывести символ R0 на экран
	MOV	#000060, R0
	SUB	#001750, R4	; 1000.
	BMI	Z20042
Z20042:	ADD	#001750, R4	; готова цифра тысяч
	CALL	TTYOUT		; вывести символ R0 на экран
; Вход: вывести 3-значное число R4
Z20050:	MOV	#000060, R0
	SUB	#000144, R4	; 100.
	BMI	Z20066
Z20066:	ADD	#000144, R4	; Готова цифра сотен
	CALL	TTYOUT		; вывести символ R0 на экран
; Вход: вывести двузначное число R4
Z20074:	MOV	#000060, R0
Z20100:	SUB	#000012, R4
	BMI	Z20112
	INC	R0
	BR	Z20100
Z20112:	ADD	#000012, R4	; готова цифра десятков
	CALL	TTYOUT		; вывести символ R0 на экран
	MOV	#000060, R0
	ADD	R4, R0		; готова последняя цифра
	CALL	TTYOUT		; вывести символ R0 на экран
Z20130:	RETURN
;
SCOREP:	.BYTE	33,131,66,53,0	; Esc Y <стр>,<кол> -- курсор туда где очки
	.EVEN
; Подпрограмма: вывод статусной строки -- теперь здесь только очки
Z20172:
Z20236:
	MOV	#SCOREP, R1
	CALL	PRINT
	MOV	Z01776, R4	; получаем текущее количество очков
	JMP	Z20000		; Вывести 5-значное число R4
;
Z20302:	TST	Z01776		; количество очков нулевое?
Z20306:	BEQ	Z20314
;
Z20314:	RETURN	
;
Z20316:	CLR	Z01702		; Очищаем количество человеков
	MOV	#000232, R0	; ???
;	EMT	000016		; драйвер ТВ-монитора
Z20330:	RETURN	

; Подпрограмма: ???
Z20364:	CALL	Z17000
	CLR	Z11302
	RETURN	
; Подпрограмма ??? R2 = адес в растре, R3 = адрес в образе лабиринта
Z20376:	TST	Z01736		; равен нулю?
	BEQ	Z20422		; да => выводим как есть, иначе на 5 строк выше
	SUB	#000500, R2	; минус 5 строк растра
	CALL	Z05500		; Вывод игрового объекта
	ADD	#000500, R2	; плюс 5 строк растра
	BR	Z20426
Z20422:	CALL	Z05500		; Вывод игрового объекта
Z20426:	RETURN	
;
Z20430:	CALL	Z17276
	MOV	#000012, R2	; 10. раз
	MOV	R3, R5
Z20442:	RETURN	

; Подпрограмма: ???
Z20540:	MOV	#000001, Z01770	; Номер лабиринта = 1
	CLR	Z11312
	RETURN
	
Z21264:	CLR	R1
	CLR	R2
;	EMT	000024		; Установка курсора в (0,0)
	MOV	#043200, R0	; экран, начало 26. строки
Z21276:	CLR	(R0)+		;   очищаем 8 пикселей
	CMP	R0, #075000	;   экран, начало 232. строки
	BMI	Z21276		;   повторяем
Z21306:	RETURN
;
; Прерывание по клавише СТОП или зависанию (вектор 4)
; также сюда приходим после завершения игры
Z21310:	MOV	#001000, SP	; Инициализация стека
	NOP	
	NOP	
	NOP	
	MOV	#000040, R1	; По адресу 000040
	MOV	#000120, R2	; 80. слов, 160. байт
Z21332:	CLR	(R1)+		;   очищаем слово
	SOB	R2, Z21332	;   повторяем
	CALL	Z22720
Z21342:	BR	Z21350
;
Z21350:	TRAP	000000		; вывод строки
	.WORD	010000, 000006	; 
	MOV	#021630, 000274
Z21364:	JMP	Z01064		; Переход к формированию экрана меню


Z21636:	JMP	Z22046

; Цикл ожидания -- здесь крутимся после вывода картинки уровня
Z21642:
;	TSTB	@#177560	; Нажали клавишу?
;	BPL	Z21642		; если нет то ждём дальше
;	MOV	@#177562, R0	; код нажатой клавиши
	SUB	#000060, R0
Z21660:	BMI	Z21676

Z21676:	RETURN	

; Обработчик прерывания TRAP (вектор 34)
Z21730:	MOV	R5, -(SP)
	MOV	R0, -(SP)
	MOV	000004(SP), R5	; Сохранённый CPC
	MOV	-(R5), R0	; Получаем команду вызвавшую TRAP
	MOVB	R0, R0		; Код TRAP = 0 ?
	BEQ	Z21760		; да => переходим
	CALL	102234		;TODO вызов EMT 16 - вывод символа из мл байта R0
Z21752:	MOV	(SP)+, R0
	MOV	(SP)+, R5
Z21756:	RTI			; возврат из прерывания
; TRAP 000000
Z21760:	MOV	R1, -(SP)
	MOV	R2, -(SP)
	TST	(R5)+		; пропускаем саму команду
	MOV	(R5)+, R1	; адрес строки символов
	MOV	(R5)+, R2	; длина мл байт, символ огр ст байт
	MOV	R5, 000010(SP)	; после этих двух слов место откуда продолжать
	CALL	107050		;TODO EMT 20 - вывод строки символов
	MOV	(SP)+, R2
	MOV	(SP)+, R1
Z22006:	BR	Z21752		; завершаем обработку TRAP
; Установка курсора по координатам
Z22010:	MOV	R5, -(SP)
	MOV	R1, -(SP)
	MOV	R2, -(SP)
	MOV	000006(SP), R5
	MOVB	(R5)+, R1
	MOVB	(R5)+, R2
	MOV	R5, 000006(SP)
	CALL	107272		;TODO EMT 24 - установка курсора по координатам
	MOV	(SP)+, R2
	MOV	(SP)+, R1
	MOV	(SP)+, R5
Z22044:	RTI			; возврат из прерывания
; ??? Что-то с клавиатурой
Z22046:	TST	@#177562	; регистр данных клавиатуры
	TST	Z01754
Z22056:	BNE	Z22064
Z22060:	JMP	Z21642		; Переходим к ожиданию нажатия клавиши
Z22064:	RETURN	;STUB

	.BLKW	637		; ADDRESS ALIGNMENT GAP
; ??? данные -- игровые объекты
Z22070::
	.BLKW	10		;TODO: Уточнить, неясно сколько нужно
Z22072	= Z22070 + 2

Z22720:	COMB	@#000053
	COM	@#000220
	MOV	#021310, 000004	; задаём адрес вектора 4
	CALL	100206		;TODO ???
	MOV	#177777, 177714	;TODO в выходной регистр порта
Z22750:	RETURN	

Z22770:	TST	Z01754
	BNE	Z23004
	MOV	177562, R0	;TODO
Z23002:	RETURN	
Z23004:	RETURN	;STUB

Z23052:	CLR	Z01736
	CMPB	(R1), #000006
	BEQ	Z23066
	CLRB	(R1)
Z23066:	RETURN	

Z23150:	MOV	#000045, R5
	CALL	Z23224
	CMP	R3, #000003	; R3 >= 3 ?
	BPL	Z23176
Z23166:	MOV	R4, R3
	MOV	#000001, R5
Z23174:	RETURN	
;
Z23176:	CLR	R5
Z23200:	RETURN	
Z23202:	MOV	#000045, R5
	CALL	Z23224
	CMP	R3, #000003
	BMI	Z23176
	BR	Z23166
Z23222:	.WORD	0
Z23224:	MOV	Z23222, R3
	MOV	#000011, R2
Z23234:	ASL	R3
	SOB	R2, Z23234
	MOV	#000005, R2
Z23244:	SUB	Z23222, R3
	SOB	R2, Z23244
	MOV	#000017, R2
	XOR	R2, R3
	MOV	R3, Z23222
	BIC	#100000, R3
	CMP	R3, R5
	BLE	Z23312
	ASL	R5
Z23276:	CMP	R3, R5
	BLE	Z23306
	ASR	R3
	BR	Z23276
Z23306:	ASR	R5
	SUB	R5, R3
Z23312:	RETURN	

	.BLKW	617		; ADDRESS ALIGNMENT GAP
; Массив игровых объектов, следующий свободный адрес указан в 001720
Z24000::
	.BLKW	40	;TODO: Неясно сколько нужно места

	.BLKW	50		; ADDRESS ALIGNMENT GAP

.END	START
